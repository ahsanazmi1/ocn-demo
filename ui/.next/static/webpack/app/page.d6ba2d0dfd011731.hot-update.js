"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/demos/agent/realOrchestrator.ts":
/*!*********************************************!*\
  !*** ./src/demos/agent/realOrchestrator.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RealOrchestrator: function() { return /* binding */ RealOrchestrator; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ RealOrchestrator auto */ // Connect via direct API routes to avoid CORS issues\nconst API_BASE = \"/api/gateway\";\nclass RealOrchestrator {\n    generateTraceId() {\n        // Generate trace ID in Orca's expected format: txn_[16 hex chars]\n        const hex = Math.random().toString(16).substring(2, 18).padEnd(16, \"0\");\n        return \"txn_\".concat(hex);\n    }\n    async makeRequest(url) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            const response = await fetch(url, {\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-ocn-trace-id\": this.traceId,\n                    ...options.headers\n                },\n                ...options\n            });\n            if (!response.ok) {\n                return {\n                    success: false,\n                    error: \"HTTP \".concat(response.status, \": \").concat(response.statusText)\n                };\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async makeMCPRequest(agent, verb) {\n        let args = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const mcpRequest = {\n            verb,\n            args\n        };\n        return this.makeRequest(\"\".concat(API_BASE, \"/\").concat(agent, \"/mcp/invoke\"), {\n            method: \"POST\",\n            body: JSON.stringify(mcpRequest)\n        });\n    }\n    getOxfordsCart() {\n        return {\n            items: [\n                {\n                    sku: \"OXFORD-SLIM-CREW-M\",\n                    name: \"Slim-Fit Crew Oxford (M)\",\n                    unit_price: 120.0,\n                    qty: 2,\n                    category: \"clothing\"\n                },\n                {\n                    sku: \"BLAZER-NAVY-40R\",\n                    name: \"Navy Blazer\",\n                    unit_price: 140.0,\n                    qty: 1,\n                    category: \"clothing\"\n                }\n            ],\n            total: 380.0\n        };\n    }\n    async runAgentFlow(choice) {\n        const selectedChoice = choice || \"credit\";\n        const explanations = [];\n        const cart = this.getOxfordsCart();\n        const cartTotal = cart.total;\n        this.traceId = this.generateTraceId(); // Generate a new trace ID for each flow run\n        this.baseTimestamp = Date.now();\n        // Follow the 11-step event sequence from the image, using real agents when possible\n        // 1. Orca (Checkout decision)\n        let orcaResponse;\n        try {\n            orcaResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/orca/decision\"), {\n                method: \"POST\",\n                body: JSON.stringify({\n                    cart_total: cartTotal,\n                    currency: \"USD\"\n                })\n            });\n            console.log(\"\\uD83D\\uDE80 REAL AGENT: Orca decision response:\", orcaResponse.success ? \"SUCCESS\" : \"FAILED\");\n        } catch (error) {\n            console.warn(\"\\uD83D\\uDE80 REAL AGENT: Orca decision failed, using fallback:\", error);\n            orcaResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"orca_checkout_001\",\n            agent: \"orca\",\n            model_version: \"orca_decision_ml_v4.1.8\",\n            policy_version: \"checkout_v1.0.0\",\n            summary: \"Checkout initiated for $\".concat(cartTotal, \" transaction. Analyzing payment options and risk factors...\"),\n            decision: \"pending\",\n            score: 0.5,\n            score_type: \"risk\",\n            uncertainty: 0.1,\n            key_signals: [\n                {\n                    path: \"cart.total\",\n                    value: cartTotal,\n                    weight: 0.5\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 1000).toISOString(),\n            extra: {\n                status: \"initiated\",\n                real_data: orcaResponse.success\n            }\n        });\n        // 2. Opal (Wallet method selected)\n        const opalMethod = selectedChoice === \"credit\" ? \"credit_card\" : \"bnpl\";\n        let opalResponse;\n        try {\n            opalResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/opal/wallet/methods?actor_id=demo_actor\"));\n            console.log(\"\\uD83D\\uDE80 REAL AGENT: Opal wallet methods response:\", opalResponse.success ? \"SUCCESS\" : \"FAILED\");\n        } catch (error) {\n            console.warn(\"\\uD83D\\uDE80 REAL AGENT: Opal wallet methods failed, using fallback:\", error);\n            opalResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"opal_wallet_002\",\n            agent: \"opal\",\n            model_version: \"opal_wallet_ml_v3.0.1\",\n            policy_version: \"wallet_v1.8.2\",\n            summary: \"\".concat(selectedChoice === \"credit\" ? \"Credit card\" : \"BNPL\", \" selected as payment method. Card ending in ****1234 has sufficient credit limit...\"),\n            decision: \"allow\",\n            score: 0.9,\n            score_type: \"suitability\",\n            uncertainty: 0.05,\n            key_signals: [\n                {\n                    path: \"payment.method\",\n                    value: opalMethod,\n                    weight: 0.8\n                }\n            ],\n            ap2_refs: [],\n            redactions: [\n                \"card_number\"\n            ],\n            timestamp: new Date(this.baseTimestamp + 2000).toISOString(),\n            extra: {\n                method: opalMethod,\n                real_data: opalResponse.success\n            }\n        });\n        // 3. Olive (Loyalty incentives applied)\n        const cashbackAmount = selectedChoice === \"credit\" ? (cartTotal * 0.05).toFixed(2) : \"0.00\";\n        let oliveResponse;\n        try {\n            oliveResponse = await this.makeMCPRequest(\"olive\", \"getIncentives\", {\n                amount: cartTotal,\n                payment_method: selectedChoice,\n                customer_tier: \"gold\"\n            });\n            console.log(\"\\uD83D\\uDE80 REAL AGENT: Olive incentives response:\", oliveResponse.success ? \"SUCCESS\" : \"FAILED\");\n        } catch (error) {\n            console.warn(\"\\uD83D\\uDE80 REAL AGENT: Olive incentives failed, using fallback:\", error);\n            oliveResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"olive_loyalty_003\",\n            agent: \"olive\",\n            model_version: \"olive_loyalty_ml_v1.9.3\",\n            policy_version: \"loyalty_v2.4.1\",\n            summary: selectedChoice === \"credit\" ? \"Excellent! Credit card selected. You'll earn 5% cash back = $\".concat(cashbackAmount, \". Gold tier benefits apply...\") : \"BNPL selected. No loyalty incentives apply for this payment method.\",\n            decision: \"allow\",\n            score: selectedChoice === \"credit\" ? 0.95 : 0.7,\n            score_type: \"value\",\n            uncertainty: 0.02,\n            key_signals: [\n                {\n                    path: \"loyalty.tier\",\n                    value: \"gold\",\n                    weight: 0.7\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 3000).toISOString(),\n            extra: {\n                cashback: cashbackAmount,\n                real_data: oliveResponse.success\n            }\n        });\n        // 4. Okra (BNPL quote generated)\n        const bnplPayment = Math.round(cartTotal / 4);\n        let okraResponse;\n        try {\n            okraResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/okra/bnpl/quote\"), {\n                method: \"POST\",\n                body: JSON.stringify({\n                    amount: cartTotal,\n                    tenor: 4,\n                    on_time_rate: 0.95,\n                    utilization: 0.31\n                })\n            });\n        } catch (error) {\n            console.warn(\"Okra BNPL quote failed, using fallback:\", error);\n            okraResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"okra_bnpl_004\",\n            agent: \"okra\",\n            model_version: \"okra_bnpl_ml_v1.0.0\",\n            policy_version: \"bnpl_v1.0.0\",\n            summary: \"BNPL quote generated: 4 payments of $\".concat(bnplPayment, \" each, 0% interest, no fees...\"),\n            decision: \"propose_alt\",\n            score: 0.85,\n            score_type: \"affordability\",\n            uncertainty: 0.08,\n            key_signals: [\n                {\n                    path: \"bnpl.installments\",\n                    value: 4,\n                    weight: 0.6\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 4000).toISOString(),\n            extra: {\n                installments: 4,\n                amount_per_payment: bnplPayment,\n                real_data: okraResponse.success\n            }\n        });\n        // 5. Onyx (KYB verification CE emitted)\n        let onyxResponse;\n        try {\n            onyxResponse = await this.makeMCPRequest(\"onyx\", \"getTrustSignal\", {\n                trace_id: this.traceId,\n                context: {\n                    device_reputation: 0.8,\n                    velocity: 1.5,\n                    ip_risk: 0.2,\n                    history_len: 25\n                }\n            });\n        } catch (error) {\n            console.warn(\"Onyx KYB verification failed, using fallback:\", error);\n            onyxResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"onyx_kyb_005\",\n            agent: \"onyx\",\n            model_version: \"onyx_kyb_ml_v2.0.0\",\n            policy_version: \"kyb_v1.1.0\",\n            summary: \"KYB verification completed. Customer identity verified through multiple data sources...\",\n            decision: \"allow\",\n            score: 0.98,\n            score_type: \"trust\",\n            uncertainty: 0.01,\n            key_signals: [\n                {\n                    path: \"kyb.status\",\n                    value: \"verified\",\n                    weight: 0.9\n                }\n            ],\n            ap2_refs: [],\n            redactions: [\n                \"customer_id_full\"\n            ],\n            timestamp: new Date(this.baseTimestamp + 5000).toISOString(),\n            extra: {\n                kyb_status: \"verified\",\n                real_data: onyxResponse.success\n            }\n        });\n        // 6. Orca vs Opal (Negotiation + LLM explanations)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"orca_opal_negotiation_006\",\n            agent: \"orca\",\n            model_version: \"orca_negotiation_llm_v1.0.0\",\n            policy_version: \"negotiation_v1.0.0\",\n            summary: \"Negotiation with Opal complete. Optimized payment terms agreed: \".concat(selectedChoice === \"credit\" ? \"Credit card with 5% cashback ($\".concat(cashbackAmount, \")\") : \"BNPL (4x$\".concat(bnplPayment, \")\"), \".\"),\n            decision: \"allow\",\n            score: 0.92,\n            score_type: \"optimization\",\n            uncertainty: 0.07,\n            key_signals: [\n                {\n                    path: \"negotiation.outcome\",\n                    value: \"optimized\",\n                    weight: 0.8\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 6000).toISOString(),\n            extra: {\n                negotiated_terms: selectedChoice,\n                real_data: orcaResponse.success\n            }\n        });\n        // 7. Weave (Processor auction)\n        let weaveResponse;\n        try {\n            weaveResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/weave/auction/run\"), {\n                method: \"POST\",\n                body: JSON.stringify({\n                    amount: cartTotal,\n                    currency: \"USD\",\n                    payment_method: selectedChoice\n                })\n            });\n        } catch (error) {\n            console.warn(\"Weave auction failed, using fallback:\", error);\n            weaveResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"weave_auction_007\",\n            agent: \"weave\",\n            model_version: \"weave_auction_ml_v2.3.4\",\n            policy_version: \"auction_v4.1.2\",\n            summary: \"Processor auction complete! 3 processors bid for transaction. Winning bid: 1.5% + $2.50 processing cost...\",\n            decision: \"allow\",\n            score: 0.88,\n            score_type: \"cost\",\n            uncertainty: 0.06,\n            key_signals: [\n                {\n                    path: \"auction.winner\",\n                    value: \"ProcessorX\",\n                    weight: 0.7\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 7000).toISOString(),\n            extra: {\n                winning_processor: \"ProcessorX\",\n                cost_bps: 150,\n                real_data: weaveResponse.success\n            }\n        });\n        // 8. Final (Settlement path)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"final_settlement_008\",\n            agent: \"orca\",\n            model_version: \"orca_settlement_ml_v1.0.0\",\n            policy_version: \"settlement_v1.0.0\",\n            summary: \"Settlement path determined: Standard 2-day settlement to merchant account...\",\n            decision: \"allow\",\n            score: 0.99,\n            score_type: \"efficiency\",\n            uncertainty: 0.01,\n            key_signals: [\n                {\n                    path: \"settlement.days\",\n                    value: 2,\n                    weight: 0.9\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 8000).toISOString(),\n            extra: {\n                settlement_days: 2\n            }\n        });\n        // 9. Orca/Opal/Olive (Payment instruction compiled)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"payment_instruction_009\",\n            agent: \"opal\",\n            model_version: \"opal_instruction_ml_v1.0.0\",\n            policy_version: \"instruction_v1.0.0\",\n            summary: \"Payment instruction compiled successfully. All agent inputs integrated...\",\n            decision: \"allow\",\n            score: 0.97,\n            score_type: \"completeness\",\n            uncertainty: 0.03,\n            key_signals: [\n                {\n                    path: \"instruction.status\",\n                    value: \"compiled\",\n                    weight: 0.85\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 9000).toISOString(),\n            extra: {\n                instruction_id: \"INST-789012\"\n            }\n        });\n        // 10. Weave (Instruction signed & forwarded)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"weave_signed_010\",\n            agent: \"weave\",\n            model_version: \"weave_security_ml_v1.0.0\",\n            policy_version: \"security_v1.0.0\",\n            summary: \"Payment instruction signed with cryptographic signature and forwarded to processor...\",\n            decision: \"allow\",\n            score: 0.99,\n            score_type: \"security\",\n            uncertainty: 0.01,\n            key_signals: [\n                {\n                    path: \"signature.status\",\n                    value: \"valid\",\n                    weight: 0.95\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 10000).toISOString(),\n            extra: {\n                signature_type: \"ECDSA\"\n            }\n        });\n        // 11. Processor (Authorization result)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"processor_auth_011\",\n            agent: \"orca\",\n            model_version: \"orca_auth_ml_v1.0.0\",\n            policy_version: \"auth_v1.0.0\",\n            summary: \"Authorization successful! Transaction approved by processor. $\".concat(cartTotal, \" charged to \").concat(selectedChoice === \"credit\" ? \"credit card\" : \"BNPL account\", \"...\"),\n            decision: \"allow\",\n            score: 1.0,\n            score_type: \"final\",\n            uncertainty: 0.0,\n            key_signals: [\n                {\n                    path: \"auth.status\",\n                    value: \"approved\",\n                    weight: 1.0\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 11000).toISOString(),\n            extra: {\n                auth_code: \"ABC123XYZ\",\n                final_status: \"approved\"\n            }\n        });\n        return explanations;\n    }\n    constructor(){\n        this.traceId = this.generateTraceId();\n        this.baseTimestamp = Date.now();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kZW1vcy9hZ2VudC9yZWFsT3JjaGVzdHJhdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7c0VBSUEscURBQXFEO0FBQ3JELE1BQU1BLFdBQVc7QUFhVixNQUFNQztJQVNIQyxrQkFBMEI7UUFDaEMsa0VBQWtFO1FBQ2xFLE1BQU1DLE1BQU1DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLElBQUlDLE1BQU0sQ0FBQyxJQUFJO1FBQ25FLE9BQU8sT0FBVyxPQUFKTDtJQUNoQjtJQUVBLE1BQWNNLFlBQVlDLEdBQVcsRUFBcUQ7WUFBbkRDLFVBQUFBLGlFQUF1QixDQUFDO1FBQzdELElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU1ILEtBQUs7Z0JBQ2hDSSxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsa0JBQWtCLElBQUksQ0FBQ0MsT0FBTztvQkFDOUIsR0FBR0osUUFBUUcsT0FBTztnQkFDcEI7Z0JBQ0EsR0FBR0gsT0FBTztZQUNaO1lBRUEsSUFBSSxDQUFDQyxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLE9BQU87b0JBQUVDLFNBQVM7b0JBQU9DLE9BQU8sUUFBNEJOLE9BQXBCQSxTQUFTTyxNQUFNLEVBQUMsTUFBd0IsT0FBcEJQLFNBQVNRLFVBQVU7Z0JBQUc7WUFDcEY7WUFFQSxNQUFNQyxPQUFPLE1BQU1ULFNBQVNVLElBQUk7WUFDaEMsT0FBTztnQkFBRUwsU0FBUztnQkFBTUk7WUFBSztRQUMvQixFQUFFLE9BQU9ILE9BQU87WUFDZCxPQUFPO2dCQUFFRCxTQUFTO2dCQUFPQyxPQUFPQSxpQkFBaUJLLFFBQVFMLE1BQU1NLE9BQU8sR0FBRztZQUFnQjtRQUMzRjtJQUNGO0lBRUEsTUFBY0MsZUFBZUMsS0FBYSxFQUFFQyxJQUFZLEVBQTBEO1lBQXhEQyxPQUFBQSxpRUFBNEIsQ0FBQztRQUNyRixNQUFNQyxhQUF5QjtZQUFFRjtZQUFNQztRQUFLO1FBQzVDLE9BQU8s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O2FBQUU7WUFDekVDLFVBQVUsRUFBRTtZQUNaQyxZQUFZLEVBQUU7WUFDZEMsV0FBVyxJQUFJekIsS0FBSyxJQUFJLENBQUNELGFBQWEsR0FBRyxPQUFPMkIsV0FBVztZQUMzREMsT0FBTztnQkFBRWdDLGdCQUFnQjtZQUFRO1FBQ25DO1FBRUEsdUNBQXVDO1FBQ3ZDL0QsYUFBYWEsSUFBSSxDQUFDO1lBQ2hCQyxVQUFVLElBQUksQ0FBQzVDLE9BQU87WUFDdEI2QyxTQUFTO1lBQ1RsQyxPQUFPO1lBQ1BtQyxlQUFlO1lBQ2ZDLGdCQUFnQjtZQUNoQkMsU0FBUyxpRUFBeUZuQixPQUF4QkcsV0FBVSxnQkFBMkUsT0FBN0RILG1CQUFtQixXQUFXLGdCQUFnQixnQkFBZTtZQUMvSm9CLFVBQVU7WUFDVkMsT0FBTztZQUNQQyxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsYUFBYTtnQkFBQztvQkFBRUMsTUFBTTtvQkFBZUMsT0FBTztvQkFBWUMsUUFBUTtnQkFBSTthQUFFO1lBQ3RFQyxVQUFVLEVBQUU7WUFDWkMsWUFBWSxFQUFFO1lBQ2RDLFdBQVcsSUFBSXpCLEtBQUssSUFBSSxDQUFDRCxhQUFhLEdBQUcsT0FBTzJCLFdBQVc7WUFDM0RDLE9BQU87Z0JBQUVpQyxXQUFXO2dCQUFhQyxjQUFjO1lBQVc7UUFDNUQ7UUFFQSxPQUFPakU7SUFDVDtJQWpYQWtFLGFBQWM7UUFDWixJQUFJLENBQUNoRyxPQUFPLEdBQUcsSUFBSSxDQUFDYixlQUFlO1FBQ25DLElBQUksQ0FBQzhDLGFBQWEsR0FBR0MsS0FBS0MsR0FBRztJQUMvQjtBQStXRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZGVtb3MvYWdlbnQvcmVhbE9yY2hlc3RyYXRvci50cz81MDJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgRXhwbGFuYXRpb24sIENhcnQgfSBmcm9tICcuL3R5cGVzJztcblxuLy8gQ29ubmVjdCB2aWEgZGlyZWN0IEFQSSByb3V0ZXMgdG8gYXZvaWQgQ09SUyBpc3N1ZXNcbmNvbnN0IEFQSV9CQVNFID0gJy9hcGkvZ2F0ZXdheSc7XG5cbmludGVyZmFjZSBBZ2VudFJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZGF0YT86IGFueTtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNQ1BSZXF1ZXN0IHtcbiAgdmVyYjogc3RyaW5nO1xuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5leHBvcnQgY2xhc3MgUmVhbE9yY2hlc3RyYXRvciB7XG4gIHByaXZhdGUgdHJhY2VJZDogc3RyaW5nO1xuICBwcml2YXRlIGJhc2VUaW1lc3RhbXA6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRyYWNlSWQgPSB0aGlzLmdlbmVyYXRlVHJhY2VJZCgpO1xuICAgIHRoaXMuYmFzZVRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlVHJhY2VJZCgpOiBzdHJpbmcge1xuICAgIC8vIEdlbmVyYXRlIHRyYWNlIElEIGluIE9yY2EncyBleHBlY3RlZCBmb3JtYXQ6IHR4bl9bMTYgaGV4IGNoYXJzXVxuICAgIGNvbnN0IGhleCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygyLCAxOCkucGFkRW5kKDE2LCAnMCcpO1xuICAgIHJldHVybiBgdHhuXyR7aGV4fWA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1ha2VSZXF1ZXN0KHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9KTogUHJvbWlzZTxBZ2VudFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICd4LW9jbi10cmFjZS1pZCc6IHRoaXMudHJhY2VJZCxcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbWFrZU1DUFJlcXVlc3QoYWdlbnQ6IHN0cmluZywgdmVyYjogc3RyaW5nLCBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBQcm9taXNlPEFnZW50UmVzcG9uc2U+IHtcbiAgICBjb25zdCBtY3BSZXF1ZXN0OiBNQ1BSZXF1ZXN0ID0geyB2ZXJiLCBhcmdzIH07XG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoYCR7QVBJX0JBU0V9LyR7YWdlbnR9L21jcC9pbnZva2VgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1jcFJlcXVlc3QpLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0T3hmb3Jkc0NhcnQoKTogQ2FydCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBza3U6ICdPWEZPUkQtU0xJTS1DUkVXLU0nLFxuICAgICAgICAgIG5hbWU6ICdTbGltLUZpdCBDcmV3IE94Zm9yZCAoTSknLFxuICAgICAgICAgIHVuaXRfcHJpY2U6IDEyMC4wLFxuICAgICAgICAgIHF0eTogMixcbiAgICAgICAgICBjYXRlZ29yeTogJ2Nsb3RoaW5nJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2t1OiAnQkxBWkVSLU5BVlktNDBSJyxcbiAgICAgICAgICBuYW1lOiAnTmF2eSBCbGF6ZXInLFxuICAgICAgICAgIHVuaXRfcHJpY2U6IDE0MC4wLFxuICAgICAgICAgIHF0eTogMSxcbiAgICAgICAgICBjYXRlZ29yeTogJ2Nsb3RoaW5nJ1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdG90YWw6IDM4MC4wXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJ1bkFnZW50RmxvdyhjaG9pY2U/OiAnY3JlZGl0JyB8ICdibnBsJyk6IFByb21pc2U8RXhwbGFuYXRpb25bXT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkQ2hvaWNlID0gY2hvaWNlIHx8ICdjcmVkaXQnO1xuICAgIGNvbnN0IGV4cGxhbmF0aW9uczogRXhwbGFuYXRpb25bXSA9IFtdO1xuICAgIGNvbnN0IGNhcnQgPSB0aGlzLmdldE94Zm9yZHNDYXJ0KCk7XG4gICAgY29uc3QgY2FydFRvdGFsID0gY2FydC50b3RhbDtcblxuICAgIHRoaXMudHJhY2VJZCA9IHRoaXMuZ2VuZXJhdGVUcmFjZUlkKCk7IC8vIEdlbmVyYXRlIGEgbmV3IHRyYWNlIElEIGZvciBlYWNoIGZsb3cgcnVuXG4gICAgdGhpcy5iYXNlVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIEZvbGxvdyB0aGUgMTEtc3RlcCBldmVudCBzZXF1ZW5jZSBmcm9tIHRoZSBpbWFnZSwgdXNpbmcgcmVhbCBhZ2VudHMgd2hlbiBwb3NzaWJsZVxuICAgIC8vIDEuIE9yY2EgKENoZWNrb3V0IGRlY2lzaW9uKVxuICAgIGxldCBvcmNhUmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgICBvcmNhUmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAke1BST1hZX0JBU0V9L29yY2EvZGVjaXNpb25gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNhcnRfdG90YWw6IGNhcnRUb3RhbCwgY3VycmVuY3k6ICdVU0QnIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFJFQUwgQUdFTlQ6IE9yY2EgZGVjaXNpb24gcmVzcG9uc2U6Jywgb3JjYVJlc3BvbnNlLnN1Y2Nlc3MgPyAnU1VDQ0VTUycgOiAnRkFJTEVEJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2Fybign8J+agCBSRUFMIEFHRU5UOiBPcmNhIGRlY2lzaW9uIGZhaWxlZCwgdXNpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgb3JjYVJlc3BvbnNlID0geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGV4cGxhbmF0aW9ucy5wdXNoKHtcbiAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlSWQsXG4gICAgICBzdGVwX2lkOiAnb3JjYV9jaGVja291dF8wMDEnLFxuICAgICAgYWdlbnQ6ICdvcmNhJyxcbiAgICAgIG1vZGVsX3ZlcnNpb246ICdvcmNhX2RlY2lzaW9uX21sX3Y0LjEuOCcsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ2NoZWNrb3V0X3YxLjAuMCcsXG4gICAgICBzdW1tYXJ5OiBgQ2hlY2tvdXQgaW5pdGlhdGVkIGZvciAkJHtjYXJ0VG90YWx9IHRyYW5zYWN0aW9uLiBBbmFseXppbmcgcGF5bWVudCBvcHRpb25zIGFuZCByaXNrIGZhY3RvcnMuLi5gLFxuICAgICAgZGVjaXNpb246ICdwZW5kaW5nJyxcbiAgICAgIHNjb3JlOiAwLjUsXG4gICAgICBzY29yZV90eXBlOiAncmlzaycsXG4gICAgICB1bmNlcnRhaW50eTogMC4xLFxuICAgICAga2V5X3NpZ25hbHM6IFt7IHBhdGg6ICdjYXJ0LnRvdGFsJywgdmFsdWU6IGNhcnRUb3RhbCwgd2VpZ2h0OiAwLjUgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IHN0YXR1czogJ2luaXRpYXRlZCcsIHJlYWxfZGF0YTogb3JjYVJlc3BvbnNlLnN1Y2Nlc3MgfVxuICAgIH0pO1xuXG4gICAgLy8gMi4gT3BhbCAoV2FsbGV0IG1ldGhvZCBzZWxlY3RlZClcbiAgICBjb25zdCBvcGFsTWV0aG9kID0gc2VsZWN0ZWRDaG9pY2UgPT09ICdjcmVkaXQnID8gJ2NyZWRpdF9jYXJkJyA6ICdibnBsJztcbiAgICBsZXQgb3BhbFJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICAgICAgb3BhbFJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgJHtQUk9YWV9CQVNFfS9vcGFsL3dhbGxldC9tZXRob2RzP2FjdG9yX2lkPWRlbW9fYWN0b3JgKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFJFQUwgQUdFTlQ6IE9wYWwgd2FsbGV0IG1ldGhvZHMgcmVzcG9uc2U6Jywgb3BhbFJlc3BvbnNlLnN1Y2Nlc3MgPyAnU1VDQ0VTUycgOiAnRkFJTEVEJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2Fybign8J+agCBSRUFMIEFHRU5UOiBPcGFsIHdhbGxldCBtZXRob2RzIGZhaWxlZCwgdXNpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgb3BhbFJlc3BvbnNlID0geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGV4cGxhbmF0aW9ucy5wdXNoKHtcbiAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlSWQsXG4gICAgICBzdGVwX2lkOiAnb3BhbF93YWxsZXRfMDAyJyxcbiAgICAgIGFnZW50OiAnb3BhbCcsXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnb3BhbF93YWxsZXRfbWxfdjMuMC4xJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAnd2FsbGV0X3YxLjguMicsXG4gICAgICBzdW1tYXJ5OiBgJHtzZWxlY3RlZENob2ljZSA9PT0gJ2NyZWRpdCcgPyAnQ3JlZGl0IGNhcmQnIDogJ0JOUEwnfSBzZWxlY3RlZCBhcyBwYXltZW50IG1ldGhvZC4gQ2FyZCBlbmRpbmcgaW4gKioqKjEyMzQgaGFzIHN1ZmZpY2llbnQgY3JlZGl0IGxpbWl0Li4uYCxcbiAgICAgIGRlY2lzaW9uOiAnYWxsb3cnLFxuICAgICAgc2NvcmU6IDAuOSxcbiAgICAgIHNjb3JlX3R5cGU6ICdzdWl0YWJpbGl0eScsXG4gICAgICB1bmNlcnRhaW50eTogMC4wNSxcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAncGF5bWVudC5tZXRob2QnLCB2YWx1ZTogb3BhbE1ldGhvZCwgd2VpZ2h0OiAwLjggfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbJ2NhcmRfbnVtYmVyJ10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDIwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBtZXRob2Q6IG9wYWxNZXRob2QsIHJlYWxfZGF0YTogb3BhbFJlc3BvbnNlLnN1Y2Nlc3MgfVxuICAgIH0pO1xuXG4gICAgLy8gMy4gT2xpdmUgKExveWFsdHkgaW5jZW50aXZlcyBhcHBsaWVkKVxuICAgIGNvbnN0IGNhc2hiYWNrQW1vdW50ID0gc2VsZWN0ZWRDaG9pY2UgPT09ICdjcmVkaXQnID8gKGNhcnRUb3RhbCAqIDAuMDUpLnRvRml4ZWQoMikgOiAnMC4wMCc7XG4gICAgbGV0IG9saXZlUmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIG9saXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VNQ1BSZXF1ZXN0KCdvbGl2ZScsICdnZXRJbmNlbnRpdmVzJywge1xuICAgICAgICBhbW91bnQ6IGNhcnRUb3RhbCxcbiAgICAgICAgcGF5bWVudF9tZXRob2Q6IHNlbGVjdGVkQ2hvaWNlLFxuICAgICAgICBjdXN0b21lcl90aWVyOiAnZ29sZCdcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coJ/CfmoAgUkVBTCBBR0VOVDogT2xpdmUgaW5jZW50aXZlcyByZXNwb25zZTonLCBvbGl2ZVJlc3BvbnNlLnN1Y2Nlc3MgPyAnU1VDQ0VTUycgOiAnRkFJTEVEJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2Fybign8J+agCBSRUFMIEFHRU5UOiBPbGl2ZSBpbmNlbnRpdmVzIGZhaWxlZCwgdXNpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgb2xpdmVSZXNwb25zZSA9IHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ29saXZlX2xveWFsdHlfMDAzJyxcbiAgICAgIGFnZW50OiAnb2xpdmUnLFxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29saXZlX2xveWFsdHlfbWxfdjEuOS4zJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAnbG95YWx0eV92Mi40LjEnLFxuICAgICAgc3VtbWFyeTogc2VsZWN0ZWRDaG9pY2UgPT09ICdjcmVkaXQnXG4gICAgICAgID8gYEV4Y2VsbGVudCEgQ3JlZGl0IGNhcmQgc2VsZWN0ZWQuIFlvdSdsbCBlYXJuIDUlIGNhc2ggYmFjayA9ICQke2Nhc2hiYWNrQW1vdW50fS4gR29sZCB0aWVyIGJlbmVmaXRzIGFwcGx5Li4uYFxuICAgICAgICA6IGBCTlBMIHNlbGVjdGVkLiBObyBsb3lhbHR5IGluY2VudGl2ZXMgYXBwbHkgZm9yIHRoaXMgcGF5bWVudCBtZXRob2QuYCxcbiAgICAgIGRlY2lzaW9uOiAnYWxsb3cnLFxuICAgICAgc2NvcmU6IHNlbGVjdGVkQ2hvaWNlID09PSAnY3JlZGl0JyA/IDAuOTUgOiAwLjcsXG4gICAgICBzY29yZV90eXBlOiAndmFsdWUnLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDIsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ2xveWFsdHkudGllcicsIHZhbHVlOiAnZ29sZCcsIHdlaWdodDogMC43IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogW10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDMwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBjYXNoYmFjazogY2FzaGJhY2tBbW91bnQsIHJlYWxfZGF0YTogb2xpdmVSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDQuIE9rcmEgKEJOUEwgcXVvdGUgZ2VuZXJhdGVkKVxuICAgIGNvbnN0IGJucGxQYXltZW50ID0gTWF0aC5yb3VuZChjYXJ0VG90YWwgLyA0KTtcbiAgICBsZXQgb2tyYVJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICBva3JhUmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAke1BST1hZX0JBU0V9L29rcmEvYm5wbC9xdW90ZWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBhbW91bnQ6IGNhcnRUb3RhbCxcbiAgICAgICAgICB0ZW5vcjogNCxcbiAgICAgICAgICBvbl90aW1lX3JhdGU6IDAuOTUsXG4gICAgICAgICAgdXRpbGl6YXRpb246IDAuMzFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ09rcmEgQk5QTCBxdW90ZSBmYWlsZWQsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIG9rcmFSZXNwb25zZSA9IHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ29rcmFfYm5wbF8wMDQnLFxuICAgICAgYWdlbnQ6ICdva3JhJyxcbiAgICAgIG1vZGVsX3ZlcnNpb246ICdva3JhX2JucGxfbWxfdjEuMC4wJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAnYm5wbF92MS4wLjAnLFxuICAgICAgc3VtbWFyeTogYEJOUEwgcXVvdGUgZ2VuZXJhdGVkOiA0IHBheW1lbnRzIG9mICQke2JucGxQYXltZW50fSBlYWNoLCAwJSBpbnRlcmVzdCwgbm8gZmVlcy4uLmAsXG4gICAgICBkZWNpc2lvbjogJ3Byb3Bvc2VfYWx0JywgLy8gU3RpbGwgcHJvcG9zZSwgZXZlbiBpZiBub3QgY2hvc2VuXG4gICAgICBzY29yZTogMC44NSxcbiAgICAgIHNjb3JlX3R5cGU6ICdhZmZvcmRhYmlsaXR5JyxcbiAgICAgIHVuY2VydGFpbnR5OiAwLjA4LFxuICAgICAga2V5X3NpZ25hbHM6IFt7IHBhdGg6ICdibnBsLmluc3RhbGxtZW50cycsIHZhbHVlOiA0LCB3ZWlnaHQ6IDAuNiB9XSxcbiAgICAgIGFwMl9yZWZzOiBbXSxcbiAgICAgIHJlZGFjdGlvbnM6IFtdLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0aGlzLmJhc2VUaW1lc3RhbXAgKyA0MDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgaW5zdGFsbG1lbnRzOiA0LCBhbW91bnRfcGVyX3BheW1lbnQ6IGJucGxQYXltZW50LCByZWFsX2RhdGE6IG9rcmFSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDUuIE9ueXggKEtZQiB2ZXJpZmljYXRpb24gQ0UgZW1pdHRlZClcbiAgICBsZXQgb255eFJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICBvbnl4UmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VNQ1BSZXF1ZXN0KCdvbnl4JywgJ2dldFRydXN0U2lnbmFsJywge1xuICAgICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgZGV2aWNlX3JlcHV0YXRpb246IDAuOCxcbiAgICAgICAgICB2ZWxvY2l0eTogMS41LFxuICAgICAgICAgIGlwX3Jpc2s6IDAuMixcbiAgICAgICAgICBoaXN0b3J5X2xlbjogMjVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignT255eCBLWUIgdmVyaWZpY2F0aW9uIGZhaWxlZCwgdXNpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgb255eFJlc3BvbnNlID0geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGV4cGxhbmF0aW9ucy5wdXNoKHtcbiAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlSWQsXG4gICAgICBzdGVwX2lkOiAnb255eF9reWJfMDA1JyxcbiAgICAgIGFnZW50OiAnb255eCcsXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnb255eF9reWJfbWxfdjIuMC4wJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAna3liX3YxLjEuMCcsXG4gICAgICBzdW1tYXJ5OiAnS1lCIHZlcmlmaWNhdGlvbiBjb21wbGV0ZWQuIEN1c3RvbWVyIGlkZW50aXR5IHZlcmlmaWVkIHRocm91Z2ggbXVsdGlwbGUgZGF0YSBzb3VyY2VzLi4uJyxcbiAgICAgIGRlY2lzaW9uOiAnYWxsb3cnLFxuICAgICAgc2NvcmU6IDAuOTgsXG4gICAgICBzY29yZV90eXBlOiAndHJ1c3QnLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDEsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ2t5Yi5zdGF0dXMnLCB2YWx1ZTogJ3ZlcmlmaWVkJywgd2VpZ2h0OiAwLjkgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbJ2N1c3RvbWVyX2lkX2Z1bGwnXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgNTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IGt5Yl9zdGF0dXM6ICd2ZXJpZmllZCcsIHJlYWxfZGF0YTogb255eFJlc3BvbnNlLnN1Y2Nlc3MgfVxuICAgIH0pO1xuXG4gICAgLy8gNi4gT3JjYSB2cyBPcGFsIChOZWdvdGlhdGlvbiArIExMTSBleHBsYW5hdGlvbnMpXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICdvcmNhX29wYWxfbmVnb3RpYXRpb25fMDA2JyxcbiAgICAgIGFnZW50OiAnb3JjYScsIC8vIE9yY2EgaXMgdGhlIG9yY2hlc3RyYXRvciBvZiBuZWdvdGlhdGlvblxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29yY2FfbmVnb3RpYXRpb25fbGxtX3YxLjAuMCcsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ25lZ290aWF0aW9uX3YxLjAuMCcsXG4gICAgICBzdW1tYXJ5OiBgTmVnb3RpYXRpb24gd2l0aCBPcGFsIGNvbXBsZXRlLiBPcHRpbWl6ZWQgcGF5bWVudCB0ZXJtcyBhZ3JlZWQ6ICR7c2VsZWN0ZWRDaG9pY2UgPT09ICdjcmVkaXQnID8gYENyZWRpdCBjYXJkIHdpdGggNSUgY2FzaGJhY2sgKCQke2Nhc2hiYWNrQW1vdW50fSlgIDogYEJOUEwgKDR4JCR7Ym5wbFBheW1lbnR9KWB9LmAsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiAwLjkyLFxuICAgICAgc2NvcmVfdHlwZTogJ29wdGltaXphdGlvbicsXG4gICAgICB1bmNlcnRhaW50eTogMC4wNyxcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAnbmVnb3RpYXRpb24ub3V0Y29tZScsIHZhbHVlOiAnb3B0aW1pemVkJywgd2VpZ2h0OiAwLjggfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgNjAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IG5lZ290aWF0ZWRfdGVybXM6IHNlbGVjdGVkQ2hvaWNlLCByZWFsX2RhdGE6IG9yY2FSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDcuIFdlYXZlIChQcm9jZXNzb3IgYXVjdGlvbilcbiAgICBsZXQgd2VhdmVSZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgd2VhdmVSZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYCR7UFJPWFlfQkFTRX0vd2VhdmUvYXVjdGlvbi9ydW5gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYW1vdW50OiBjYXJ0VG90YWwsXG4gICAgICAgICAgY3VycmVuY3k6ICdVU0QnLFxuICAgICAgICAgIHBheW1lbnRfbWV0aG9kOiBzZWxlY3RlZENob2ljZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignV2VhdmUgYXVjdGlvbiBmYWlsZWQsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIHdlYXZlUmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICd3ZWF2ZV9hdWN0aW9uXzAwNycsXG4gICAgICBhZ2VudDogJ3dlYXZlJyxcbiAgICAgIG1vZGVsX3ZlcnNpb246ICd3ZWF2ZV9hdWN0aW9uX21sX3YyLjMuNCcsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ2F1Y3Rpb25fdjQuMS4yJyxcbiAgICAgIHN1bW1hcnk6ICdQcm9jZXNzb3IgYXVjdGlvbiBjb21wbGV0ZSEgMyBwcm9jZXNzb3JzIGJpZCBmb3IgdHJhbnNhY3Rpb24uIFdpbm5pbmcgYmlkOiAxLjUlICsgJDIuNTAgcHJvY2Vzc2luZyBjb3N0Li4uJyxcbiAgICAgIGRlY2lzaW9uOiAnYWxsb3cnLFxuICAgICAgc2NvcmU6IDAuODgsXG4gICAgICBzY29yZV90eXBlOiAnY29zdCcsXG4gICAgICB1bmNlcnRhaW50eTogMC4wNixcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAnYXVjdGlvbi53aW5uZXInLCB2YWx1ZTogJ1Byb2Nlc3NvclgnLCB3ZWlnaHQ6IDAuNyB9XSxcbiAgICAgIGFwMl9yZWZzOiBbXSxcbiAgICAgIHJlZGFjdGlvbnM6IFtdLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0aGlzLmJhc2VUaW1lc3RhbXAgKyA3MDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgd2lubmluZ19wcm9jZXNzb3I6ICdQcm9jZXNzb3JYJywgY29zdF9icHM6IDE1MCwgcmVhbF9kYXRhOiB3ZWF2ZVJlc3BvbnNlLnN1Y2Nlc3MgfVxuICAgIH0pO1xuXG4gICAgLy8gOC4gRmluYWwgKFNldHRsZW1lbnQgcGF0aClcbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ2ZpbmFsX3NldHRsZW1lbnRfMDA4JyxcbiAgICAgIGFnZW50OiAnb3JjYScsIC8vIE9yY2EgZmluYWxpemVzIHNldHRsZW1lbnQgcGF0aFxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29yY2Ffc2V0dGxlbWVudF9tbF92MS4wLjAnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICdzZXR0bGVtZW50X3YxLjAuMCcsXG4gICAgICBzdW1tYXJ5OiAnU2V0dGxlbWVudCBwYXRoIGRldGVybWluZWQ6IFN0YW5kYXJkIDItZGF5IHNldHRsZW1lbnQgdG8gbWVyY2hhbnQgYWNjb3VudC4uLicsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiAwLjk5LFxuICAgICAgc2NvcmVfdHlwZTogJ2VmZmljaWVuY3knLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDEsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ3NldHRsZW1lbnQuZGF5cycsIHZhbHVlOiAyLCB3ZWlnaHQ6IDAuOSB9XSxcbiAgICAgIGFwMl9yZWZzOiBbXSxcbiAgICAgIHJlZGFjdGlvbnM6IFtdLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0aGlzLmJhc2VUaW1lc3RhbXAgKyA4MDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgc2V0dGxlbWVudF9kYXlzOiAyIH1cbiAgICB9KTtcblxuICAgIC8vIDkuIE9yY2EvT3BhbC9PbGl2ZSAoUGF5bWVudCBpbnN0cnVjdGlvbiBjb21waWxlZClcbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ3BheW1lbnRfaW5zdHJ1Y3Rpb25fMDA5JyxcbiAgICAgIGFnZW50OiAnb3BhbCcsIC8vIE9wYWwgY29tcGlsZXMgdGhlIGluc3RydWN0aW9uXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnb3BhbF9pbnN0cnVjdGlvbl9tbF92MS4wLjAnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICdpbnN0cnVjdGlvbl92MS4wLjAnLFxuICAgICAgc3VtbWFyeTogJ1BheW1lbnQgaW5zdHJ1Y3Rpb24gY29tcGlsZWQgc3VjY2Vzc2Z1bGx5LiBBbGwgYWdlbnQgaW5wdXRzIGludGVncmF0ZWQuLi4nLFxuICAgICAgZGVjaXNpb246ICdhbGxvdycsXG4gICAgICBzY29yZTogMC45NyxcbiAgICAgIHNjb3JlX3R5cGU6ICdjb21wbGV0ZW5lc3MnLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDMsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ2luc3RydWN0aW9uLnN0YXR1cycsIHZhbHVlOiAnY29tcGlsZWQnLCB3ZWlnaHQ6IDAuODUgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgOTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IGluc3RydWN0aW9uX2lkOiAnSU5TVC03ODkwMTInIH1cbiAgICB9KTtcblxuICAgIC8vIDEwLiBXZWF2ZSAoSW5zdHJ1Y3Rpb24gc2lnbmVkICYgZm9yd2FyZGVkKVxuICAgIGV4cGxhbmF0aW9ucy5wdXNoKHtcbiAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlSWQsXG4gICAgICBzdGVwX2lkOiAnd2VhdmVfc2lnbmVkXzAxMCcsXG4gICAgICBhZ2VudDogJ3dlYXZlJyxcbiAgICAgIG1vZGVsX3ZlcnNpb246ICd3ZWF2ZV9zZWN1cml0eV9tbF92MS4wLjAnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICdzZWN1cml0eV92MS4wLjAnLFxuICAgICAgc3VtbWFyeTogJ1BheW1lbnQgaW5zdHJ1Y3Rpb24gc2lnbmVkIHdpdGggY3J5cHRvZ3JhcGhpYyBzaWduYXR1cmUgYW5kIGZvcndhcmRlZCB0byBwcm9jZXNzb3IuLi4nLFxuICAgICAgZGVjaXNpb246ICdhbGxvdycsXG4gICAgICBzY29yZTogMC45OSxcbiAgICAgIHNjb3JlX3R5cGU6ICdzZWN1cml0eScsXG4gICAgICB1bmNlcnRhaW50eTogMC4wMSxcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAnc2lnbmF0dXJlLnN0YXR1cycsIHZhbHVlOiAndmFsaWQnLCB3ZWlnaHQ6IDAuOTUgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgMTAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBzaWduYXR1cmVfdHlwZTogJ0VDRFNBJyB9XG4gICAgfSk7XG5cbiAgICAvLyAxMS4gUHJvY2Vzc29yIChBdXRob3JpemF0aW9uIHJlc3VsdClcbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ3Byb2Nlc3Nvcl9hdXRoXzAxMScsXG4gICAgICBhZ2VudDogJ29yY2EnLCAvLyBPcmNhIHJlY2VpdmVzIGZpbmFsIGF1dGggcmVzdWx0XG4gICAgICBtb2RlbF92ZXJzaW9uOiAnb3JjYV9hdXRoX21sX3YxLjAuMCcsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ2F1dGhfdjEuMC4wJyxcbiAgICAgIHN1bW1hcnk6IGBBdXRob3JpemF0aW9uIHN1Y2Nlc3NmdWwhIFRyYW5zYWN0aW9uIGFwcHJvdmVkIGJ5IHByb2Nlc3Nvci4gJCR7Y2FydFRvdGFsfSBjaGFyZ2VkIHRvICR7c2VsZWN0ZWRDaG9pY2UgPT09ICdjcmVkaXQnID8gJ2NyZWRpdCBjYXJkJyA6ICdCTlBMIGFjY291bnQnfS4uLmAsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiAxLjAsXG4gICAgICBzY29yZV90eXBlOiAnZmluYWwnLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMCxcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAnYXV0aC5zdGF0dXMnLCB2YWx1ZTogJ2FwcHJvdmVkJywgd2VpZ2h0OiAxLjAgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgMTEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBhdXRoX2NvZGU6ICdBQkMxMjNYWVonLCBmaW5hbF9zdGF0dXM6ICdhcHByb3ZlZCcgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV4cGxhbmF0aW9ucztcbiAgfVxufSJdLCJuYW1lcyI6WyJBUElfQkFTRSIsIlJlYWxPcmNoZXN0cmF0b3IiLCJnZW5lcmF0ZVRyYWNlSWQiLCJoZXgiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJwYWRFbmQiLCJtYWtlUmVxdWVzdCIsInVybCIsIm9wdGlvbnMiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInRyYWNlSWQiLCJvayIsInN1Y2Nlc3MiLCJlcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsIkVycm9yIiwibWVzc2FnZSIsIm1ha2VNQ1BSZXF1ZXN0IiwiYWdlbnQiLCJ2ZXJiIiwiYXJncyIsIm1jcFJlcXVlc3QiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImdldE94Zm9yZHNDYXJ0IiwiaXRlbXMiLCJza3UiLCJuYW1lIiwidW5pdF9wcmljZSIsInF0eSIsImNhdGVnb3J5IiwidG90YWwiLCJydW5BZ2VudEZsb3ciLCJjaG9pY2UiLCJzZWxlY3RlZENob2ljZSIsImV4cGxhbmF0aW9ucyIsImNhcnQiLCJjYXJ0VG90YWwiLCJiYXNlVGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsIm9yY2FSZXNwb25zZSIsIlBST1hZX0JBU0UiLCJjYXJ0X3RvdGFsIiwiY3VycmVuY3kiLCJjb25zb2xlIiwibG9nIiwid2FybiIsInB1c2giLCJ0cmFjZV9pZCIsInN0ZXBfaWQiLCJtb2RlbF92ZXJzaW9uIiwicG9saWN5X3ZlcnNpb24iLCJzdW1tYXJ5IiwiZGVjaXNpb24iLCJzY29yZSIsInNjb3JlX3R5cGUiLCJ1bmNlcnRhaW50eSIsImtleV9zaWduYWxzIiwicGF0aCIsInZhbHVlIiwid2VpZ2h0IiwiYXAyX3JlZnMiLCJyZWRhY3Rpb25zIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJleHRyYSIsInJlYWxfZGF0YSIsIm9wYWxNZXRob2QiLCJvcGFsUmVzcG9uc2UiLCJjYXNoYmFja0Ftb3VudCIsInRvRml4ZWQiLCJvbGl2ZVJlc3BvbnNlIiwiYW1vdW50IiwicGF5bWVudF9tZXRob2QiLCJjdXN0b21lcl90aWVyIiwiY2FzaGJhY2siLCJibnBsUGF5bWVudCIsInJvdW5kIiwib2tyYVJlc3BvbnNlIiwidGVub3IiLCJvbl90aW1lX3JhdGUiLCJ1dGlsaXphdGlvbiIsImluc3RhbGxtZW50cyIsImFtb3VudF9wZXJfcGF5bWVudCIsIm9ueXhSZXNwb25zZSIsImNvbnRleHQiLCJkZXZpY2VfcmVwdXRhdGlvbiIsInZlbG9jaXR5IiwiaXBfcmlzayIsImhpc3RvcnlfbGVuIiwia3liX3N0YXR1cyIsIm5lZ290aWF0ZWRfdGVybXMiLCJ3ZWF2ZVJlc3BvbnNlIiwid2lubmluZ19wcm9jZXNzb3IiLCJjb3N0X2JwcyIsInNldHRsZW1lbnRfZGF5cyIsImluc3RydWN0aW9uX2lkIiwic2lnbmF0dXJlX3R5cGUiLCJhdXRoX2NvZGUiLCJmaW5hbF9zdGF0dXMiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/demos/agent/realOrchestrator.ts\n"));

/***/ })

});