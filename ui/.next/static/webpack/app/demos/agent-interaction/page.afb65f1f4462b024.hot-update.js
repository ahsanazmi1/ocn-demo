"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/demos/agent-interaction/page",{

/***/ "(app-pages-browser)/./src/demos/agent/realOrchestrator.ts":
/*!*********************************************!*\
  !*** ./src/demos/agent/realOrchestrator.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RealOrchestrator: function() { return /* binding */ RealOrchestrator; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ RealOrchestrator auto */ // Connect via direct API routes to avoid CORS issues\nconst API_BASE = \"/api/gateway\";\nclass RealOrchestrator {\n    generateTraceId() {\n        // Generate trace ID in Orca's expected format: txn_[16 hex chars]\n        const hex = Math.random().toString(16).substring(2, 18).padEnd(16, \"0\");\n        return \"txn_\".concat(hex);\n    }\n    async makeRequest(url) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            const response = await fetch(url, {\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-ocn-trace-id\": this.traceId,\n                    ...options.headers\n                },\n                ...options\n            });\n            if (!response.ok) {\n                return {\n                    success: false,\n                    error: \"HTTP \".concat(response.status, \": \").concat(response.statusText)\n                };\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : \"Unknown error\"\n            };\n        }\n    }\n    async makeMCPRequest(agent, verb) {\n        let args = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const mcpRequest = {\n            verb,\n            args\n        };\n        return this.makeRequest(\"\".concat(PROXY_BASE, \"/\").concat(agent, \"/mcp/invoke\"), {\n            method: \"POST\",\n            body: JSON.stringify(mcpRequest)\n        });\n    }\n    getOxfordsCart() {\n        return {\n            items: [\n                {\n                    sku: \"OXFORD-SLIM-CREW-M\",\n                    name: \"Slim-Fit Crew Oxford (M)\",\n                    unit_price: 120.0,\n                    qty: 2,\n                    category: \"clothing\"\n                },\n                {\n                    sku: \"BLAZER-NAVY-40R\",\n                    name: \"Navy Blazer\",\n                    unit_price: 140.0,\n                    qty: 1,\n                    category: \"clothing\"\n                }\n            ],\n            total: 380.0\n        };\n    }\n    async runAgentFlow(choice) {\n        const selectedChoice = choice || \"credit\";\n        const explanations = [];\n        const cart = this.getOxfordsCart();\n        const cartTotal = cart.total;\n        this.traceId = this.generateTraceId(); // Generate a new trace ID for each flow run\n        this.baseTimestamp = Date.now();\n        // Follow the 11-step event sequence from the image, using real agents when possible\n        // 1. Orca (Checkout decision)\n        let orcaResponse;\n        try {\n            orcaResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/orca/decision\"), {\n                method: \"POST\",\n                body: JSON.stringify({\n                    cart_total: cartTotal,\n                    currency: \"USD\"\n                })\n            });\n            console.log(\"\\uD83D\\uDE80 REAL AGENT: Orca decision response:\", orcaResponse.success ? \"SUCCESS\" : \"FAILED\");\n        } catch (error) {\n            console.warn(\"\\uD83D\\uDE80 REAL AGENT: Orca decision failed, using fallback:\", error);\n            orcaResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"orca_checkout_001\",\n            agent: \"orca\",\n            model_version: \"orca_decision_ml_v4.1.8\",\n            policy_version: \"checkout_v1.0.0\",\n            summary: \"Checkout initiated for $\".concat(cartTotal, \" transaction. Analyzing payment options and risk factors...\"),\n            decision: \"pending\",\n            score: 0.5,\n            score_type: \"risk\",\n            uncertainty: 0.1,\n            key_signals: [\n                {\n                    path: \"cart.total\",\n                    value: cartTotal,\n                    weight: 0.5\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 1000).toISOString(),\n            extra: {\n                status: \"initiated\",\n                real_data: orcaResponse.success\n            }\n        });\n        // 2. Opal (Wallet method selected)\n        const opalMethod = selectedChoice === \"credit\" ? \"credit_card\" : \"bnpl\";\n        let opalResponse;\n        try {\n            opalResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/opal/wallet/methods?actor_id=demo_actor\"));\n            console.log(\"\\uD83D\\uDE80 REAL AGENT: Opal wallet methods response:\", opalResponse.success ? \"SUCCESS\" : \"FAILED\");\n        } catch (error) {\n            console.warn(\"\\uD83D\\uDE80 REAL AGENT: Opal wallet methods failed, using fallback:\", error);\n            opalResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"opal_wallet_002\",\n            agent: \"opal\",\n            model_version: \"opal_wallet_ml_v3.0.1\",\n            policy_version: \"wallet_v1.8.2\",\n            summary: \"\".concat(selectedChoice === \"credit\" ? \"Credit card\" : \"BNPL\", \" selected as payment method. Card ending in ****1234 has sufficient credit limit...\"),\n            decision: \"allow\",\n            score: 0.9,\n            score_type: \"suitability\",\n            uncertainty: 0.05,\n            key_signals: [\n                {\n                    path: \"payment.method\",\n                    value: opalMethod,\n                    weight: 0.8\n                }\n            ],\n            ap2_refs: [],\n            redactions: [\n                \"card_number\"\n            ],\n            timestamp: new Date(this.baseTimestamp + 2000).toISOString(),\n            extra: {\n                method: opalMethod,\n                real_data: opalResponse.success\n            }\n        });\n        // 3. Olive (Loyalty incentives applied)\n        const cashbackAmount = selectedChoice === \"credit\" ? (cartTotal * 0.05).toFixed(2) : \"0.00\";\n        let oliveResponse;\n        try {\n            oliveResponse = await this.makeMCPRequest(\"olive\", \"getIncentives\", {\n                amount: cartTotal,\n                payment_method: selectedChoice,\n                customer_tier: \"gold\"\n            });\n            console.log(\"\\uD83D\\uDE80 REAL AGENT: Olive incentives response:\", oliveResponse.success ? \"SUCCESS\" : \"FAILED\");\n        } catch (error) {\n            console.warn(\"\\uD83D\\uDE80 REAL AGENT: Olive incentives failed, using fallback:\", error);\n            oliveResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"olive_loyalty_003\",\n            agent: \"olive\",\n            model_version: \"olive_loyalty_ml_v1.9.3\",\n            policy_version: \"loyalty_v2.4.1\",\n            summary: selectedChoice === \"credit\" ? \"Excellent! Credit card selected. You'll earn 5% cash back = $\".concat(cashbackAmount, \". Gold tier benefits apply...\") : \"BNPL selected. No loyalty incentives apply for this payment method.\",\n            decision: \"allow\",\n            score: selectedChoice === \"credit\" ? 0.95 : 0.7,\n            score_type: \"value\",\n            uncertainty: 0.02,\n            key_signals: [\n                {\n                    path: \"loyalty.tier\",\n                    value: \"gold\",\n                    weight: 0.7\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 3000).toISOString(),\n            extra: {\n                cashback: cashbackAmount,\n                real_data: oliveResponse.success\n            }\n        });\n        // 4. Okra (BNPL quote generated)\n        const bnplPayment = Math.round(cartTotal / 4);\n        let okraResponse;\n        try {\n            okraResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/okra/bnpl/quote\"), {\n                method: \"POST\",\n                body: JSON.stringify({\n                    amount: cartTotal,\n                    tenor: 4,\n                    on_time_rate: 0.95,\n                    utilization: 0.31\n                })\n            });\n        } catch (error) {\n            console.warn(\"Okra BNPL quote failed, using fallback:\", error);\n            okraResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"okra_bnpl_004\",\n            agent: \"okra\",\n            model_version: \"okra_bnpl_ml_v1.0.0\",\n            policy_version: \"bnpl_v1.0.0\",\n            summary: \"BNPL quote generated: 4 payments of $\".concat(bnplPayment, \" each, 0% interest, no fees...\"),\n            decision: \"propose_alt\",\n            score: 0.85,\n            score_type: \"affordability\",\n            uncertainty: 0.08,\n            key_signals: [\n                {\n                    path: \"bnpl.installments\",\n                    value: 4,\n                    weight: 0.6\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 4000).toISOString(),\n            extra: {\n                installments: 4,\n                amount_per_payment: bnplPayment,\n                real_data: okraResponse.success\n            }\n        });\n        // 5. Onyx (KYB verification CE emitted)\n        let onyxResponse;\n        try {\n            onyxResponse = await this.makeMCPRequest(\"onyx\", \"getTrustSignal\", {\n                trace_id: this.traceId,\n                context: {\n                    device_reputation: 0.8,\n                    velocity: 1.5,\n                    ip_risk: 0.2,\n                    history_len: 25\n                }\n            });\n        } catch (error) {\n            console.warn(\"Onyx KYB verification failed, using fallback:\", error);\n            onyxResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"onyx_kyb_005\",\n            agent: \"onyx\",\n            model_version: \"onyx_kyb_ml_v2.0.0\",\n            policy_version: \"kyb_v1.1.0\",\n            summary: \"KYB verification completed. Customer identity verified through multiple data sources...\",\n            decision: \"allow\",\n            score: 0.98,\n            score_type: \"trust\",\n            uncertainty: 0.01,\n            key_signals: [\n                {\n                    path: \"kyb.status\",\n                    value: \"verified\",\n                    weight: 0.9\n                }\n            ],\n            ap2_refs: [],\n            redactions: [\n                \"customer_id_full\"\n            ],\n            timestamp: new Date(this.baseTimestamp + 5000).toISOString(),\n            extra: {\n                kyb_status: \"verified\",\n                real_data: onyxResponse.success\n            }\n        });\n        // 6. Orca vs Opal (Negotiation + LLM explanations)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"orca_opal_negotiation_006\",\n            agent: \"orca\",\n            model_version: \"orca_negotiation_llm_v1.0.0\",\n            policy_version: \"negotiation_v1.0.0\",\n            summary: \"Negotiation with Opal complete. Optimized payment terms agreed: \".concat(selectedChoice === \"credit\" ? \"Credit card with 5% cashback ($\".concat(cashbackAmount, \")\") : \"BNPL (4x$\".concat(bnplPayment, \")\"), \".\"),\n            decision: \"allow\",\n            score: 0.92,\n            score_type: \"optimization\",\n            uncertainty: 0.07,\n            key_signals: [\n                {\n                    path: \"negotiation.outcome\",\n                    value: \"optimized\",\n                    weight: 0.8\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 6000).toISOString(),\n            extra: {\n                negotiated_terms: selectedChoice,\n                real_data: orcaResponse.success\n            }\n        });\n        // 7. Weave (Processor auction)\n        let weaveResponse;\n        try {\n            weaveResponse = await this.makeRequest(\"\".concat(PROXY_BASE, \"/weave/auction/run\"), {\n                method: \"POST\",\n                body: JSON.stringify({\n                    amount: cartTotal,\n                    currency: \"USD\",\n                    payment_method: selectedChoice\n                })\n            });\n        } catch (error) {\n            console.warn(\"Weave auction failed, using fallback:\", error);\n            weaveResponse = {\n                success: false\n            };\n        }\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"weave_auction_007\",\n            agent: \"weave\",\n            model_version: \"weave_auction_ml_v2.3.4\",\n            policy_version: \"auction_v4.1.2\",\n            summary: \"Processor auction complete! 3 processors bid for transaction. Winning bid: 1.5% + $2.50 processing cost...\",\n            decision: \"allow\",\n            score: 0.88,\n            score_type: \"cost\",\n            uncertainty: 0.06,\n            key_signals: [\n                {\n                    path: \"auction.winner\",\n                    value: \"ProcessorX\",\n                    weight: 0.7\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 7000).toISOString(),\n            extra: {\n                winning_processor: \"ProcessorX\",\n                cost_bps: 150,\n                real_data: weaveResponse.success\n            }\n        });\n        // 8. Final (Settlement path)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"final_settlement_008\",\n            agent: \"orca\",\n            model_version: \"orca_settlement_ml_v1.0.0\",\n            policy_version: \"settlement_v1.0.0\",\n            summary: \"Settlement path determined: Standard 2-day settlement to merchant account...\",\n            decision: \"allow\",\n            score: 0.99,\n            score_type: \"efficiency\",\n            uncertainty: 0.01,\n            key_signals: [\n                {\n                    path: \"settlement.days\",\n                    value: 2,\n                    weight: 0.9\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 8000).toISOString(),\n            extra: {\n                settlement_days: 2\n            }\n        });\n        // 9. Orca/Opal/Olive (Payment instruction compiled)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"payment_instruction_009\",\n            agent: \"opal\",\n            model_version: \"opal_instruction_ml_v1.0.0\",\n            policy_version: \"instruction_v1.0.0\",\n            summary: \"Payment instruction compiled successfully. All agent inputs integrated...\",\n            decision: \"allow\",\n            score: 0.97,\n            score_type: \"completeness\",\n            uncertainty: 0.03,\n            key_signals: [\n                {\n                    path: \"instruction.status\",\n                    value: \"compiled\",\n                    weight: 0.85\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 9000).toISOString(),\n            extra: {\n                instruction_id: \"INST-789012\"\n            }\n        });\n        // 10. Weave (Instruction signed & forwarded)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"weave_signed_010\",\n            agent: \"weave\",\n            model_version: \"weave_security_ml_v1.0.0\",\n            policy_version: \"security_v1.0.0\",\n            summary: \"Payment instruction signed with cryptographic signature and forwarded to processor...\",\n            decision: \"allow\",\n            score: 0.99,\n            score_type: \"security\",\n            uncertainty: 0.01,\n            key_signals: [\n                {\n                    path: \"signature.status\",\n                    value: \"valid\",\n                    weight: 0.95\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 10000).toISOString(),\n            extra: {\n                signature_type: \"ECDSA\"\n            }\n        });\n        // 11. Processor (Authorization result)\n        explanations.push({\n            trace_id: this.traceId,\n            step_id: \"processor_auth_011\",\n            agent: \"orca\",\n            model_version: \"orca_auth_ml_v1.0.0\",\n            policy_version: \"auth_v1.0.0\",\n            summary: \"Authorization successful! Transaction approved by processor. $\".concat(cartTotal, \" charged to \").concat(selectedChoice === \"credit\" ? \"credit card\" : \"BNPL account\", \"...\"),\n            decision: \"allow\",\n            score: 1.0,\n            score_type: \"final\",\n            uncertainty: 0.0,\n            key_signals: [\n                {\n                    path: \"auth.status\",\n                    value: \"approved\",\n                    weight: 1.0\n                }\n            ],\n            ap2_refs: [],\n            redactions: [],\n            timestamp: new Date(this.baseTimestamp + 11000).toISOString(),\n            extra: {\n                auth_code: \"ABC123XYZ\",\n                final_status: \"approved\"\n            }\n        });\n        return explanations;\n    }\n    constructor(){\n        this.traceId = this.generateTraceId();\n        this.baseTimestamp = Date.now();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kZW1vcy9hZ2VudC9yZWFsT3JjaGVzdHJhdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7c0VBSUEscURBQXFEO0FBQ3JELE1BQU1BLFdBQVc7QUFhVixNQUFNQztJQVNIQyxrQkFBMEI7UUFDaEMsa0VBQWtFO1FBQ2xFLE1BQU1DLE1BQU1DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHLElBQUlDLE1BQU0sQ0FBQyxJQUFJO1FBQ25FLE9BQU8sT0FBVyxPQUFKTDtJQUNoQjtJQUVBLE1BQWNNLFlBQVlDLEdBQVcsRUFBcUQ7WUFBbkRDLFVBQUFBLGlFQUF1QixDQUFDO1FBQzdELElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU1ILEtBQUs7Z0JBQ2hDSSxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsa0JBQWtCLElBQUksQ0FBQ0MsT0FBTztvQkFDOUIsR0FBR0osUUFBUUcsT0FBTztnQkFDcEI7Z0JBQ0EsR0FBR0gsT0FBTztZQUNaO1lBRUEsSUFBSSxDQUFDQyxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLE9BQU87b0JBQUVDLFNBQVM7b0JBQU9DLE9BQU8sUUFBNEJOLE9BQXBCQSxTQUFTTyxNQUFNLEVBQUMsTUFBd0IsT0FBcEJQLFNBQVNRLFVBQVU7Z0JBQUc7WUFDcEY7WUFFQSxNQUFNQyxPQUFPLE1BQU1ULFNBQVNVLElBQUk7WUFDaEMsT0FBTztnQkFBRUwsU0FBUztnQkFBTUk7WUFBSztRQUMvQixFQUFFLE9BQU9ILE9BQU87WUFDZCxPQUFPO2dCQUFFRCxTQUFTO2dCQUFPQyxPQUFPQSxpQkFBaUJLLFFBQVFMLE1BQU1NLE9BQU8sR0FBRztZQUFnQjtRQUMzRjtJQUNGO0lBRUEsTUFBY0MsZUFBZUMsS0FBYSxFQUFFQyxJQUFZLEVBQTBEO1lBQXhEQyxPQUFBQSxpRUFBNEIsQ0FBQztRQUNyRixNQUFNQyxhQUF5QjtZQUFFRjtZQUFNQztRQUFLO1FBQzVDLE9BQU8s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RTtZQUN6RUMsVUFBVSxFQUFFO1lBQ1pDLFlBQVksRUFBRTtZQUNkQyxXQUFXLElBQUl4QixLQUFLLElBQUksQ0FBQ0QsYUFBYSxHQUFHLE9BQU8wQixXQUFXO1lBQzNEQyxPQUFPO2dCQUFFZ0MsZ0JBQWdCO1lBQVE7UUFDbkM7UUFFQSx1Q0FBdUM7UUFDdkM5RCxhQUFhWSxJQUFJLENBQUM7WUFDaEJDLFVBQVUsSUFBSSxDQUFDNUMsT0FBTztZQUN0QjZDLFNBQVM7WUFDVGxDLE9BQU87WUFDUG1DLGVBQWU7WUFDZkMsZ0JBQWdCO1lBQ2hCQyxTQUFTLGlFQUF5RmxCLE9BQXhCRyxXQUFVLGdCQUEyRSxPQUE3REgsbUJBQW1CLFdBQVcsZ0JBQWdCLGdCQUFlO1lBQy9KbUIsVUFBVTtZQUNWQyxPQUFPO1lBQ1BDLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxhQUFhO2dCQUFDO29CQUFFQyxNQUFNO29CQUFlQyxPQUFPO29CQUFZQyxRQUFRO2dCQUFJO2FBQUU7WUFDdEVDLFVBQVUsRUFBRTtZQUNaQyxZQUFZLEVBQUU7WUFDZEMsV0FBVyxJQUFJeEIsS0FBSyxJQUFJLENBQUNELGFBQWEsR0FBRyxPQUFPMEIsV0FBVztZQUMzREMsT0FBTztnQkFBRWlDLFdBQVc7Z0JBQWFDLGNBQWM7WUFBVztRQUM1RDtRQUVBLE9BQU9oRTtJQUNUO0lBalhBaUUsYUFBYztRQUNaLElBQUksQ0FBQ2hHLE9BQU8sR0FBRyxJQUFJLENBQUNiLGVBQWU7UUFDbkMsSUFBSSxDQUFDK0MsYUFBYSxHQUFHQyxLQUFLQyxHQUFHO0lBQy9CO0FBK1dGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9kZW1vcy9hZ2VudC9yZWFsT3JjaGVzdHJhdG9yLnRzPzUwMmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBFeHBsYW5hdGlvbiwgQ2FydCB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBDb25uZWN0IHZpYSBkaXJlY3QgQVBJIHJvdXRlcyB0byBhdm9pZCBDT1JTIGlzc3Vlc1xuY29uc3QgQVBJX0JBU0UgPSAnL2FwaS9nYXRld2F5JztcblxuaW50ZXJmYWNlIEFnZW50UmVzcG9uc2Uge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogYW55O1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE1DUFJlcXVlc3Qge1xuICB2ZXJiOiBzdHJpbmc7XG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBjbGFzcyBSZWFsT3JjaGVzdHJhdG9yIHtcbiAgcHJpdmF0ZSB0cmFjZUlkOiBzdHJpbmc7XG4gIHByaXZhdGUgYmFzZVRpbWVzdGFtcDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHJhY2VJZCA9IHRoaXMuZ2VuZXJhdGVUcmFjZUlkKCk7XG4gICAgdGhpcy5iYXNlVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVUcmFjZUlkKCk6IHN0cmluZyB7XG4gICAgLy8gR2VuZXJhdGUgdHJhY2UgSUQgaW4gT3JjYSdzIGV4cGVjdGVkIGZvcm1hdDogdHhuX1sxNiBoZXggY2hhcnNdXG4gICAgY29uc3QgaGV4ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDIsIDE4KS5wYWRFbmQoMTYsICcwJyk7XG4gICAgcmV0dXJuIGB0eG5fJHtoZXh9YDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbWFrZVJlcXVlc3QodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30pOiBQcm9taXNlPEFnZW50UmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ3gtb2NuLXRyYWNlLWlkJzogdGhpcy50cmFjZUlkLFxuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlTUNQUmVxdWVzdChhZ2VudDogc3RyaW5nLCB2ZXJiOiBzdHJpbmcsIGFyZ3M6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSk6IFByb21pc2U8QWdlbnRSZXNwb25zZT4ge1xuICAgIGNvbnN0IG1jcFJlcXVlc3Q6IE1DUFJlcXVlc3QgPSB7IHZlcmIsIGFyZ3MgfTtcbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChgJHtQUk9YWV9CQVNFfS8ke2FnZW50fS9tY3AvaW52b2tlYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtY3BSZXF1ZXN0KSxcbiAgICB9KTtcbiAgfVxuXG4gIGdldE94Zm9yZHNDYXJ0KCk6IENhcnQge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtczogW1xuICAgICAgICB7XG4gICAgICAgICAgc2t1OiAnT1hGT1JELVNMSU0tQ1JFVy1NJyxcbiAgICAgICAgICBuYW1lOiAnU2xpbS1GaXQgQ3JldyBPeGZvcmQgKE0pJyxcbiAgICAgICAgICB1bml0X3ByaWNlOiAxMjAuMCxcbiAgICAgICAgICBxdHk6IDIsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdjbG90aGluZydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHNrdTogJ0JMQVpFUi1OQVZZLTQwUicsXG4gICAgICAgICAgbmFtZTogJ05hdnkgQmxhemVyJyxcbiAgICAgICAgICB1bml0X3ByaWNlOiAxNDAuMCxcbiAgICAgICAgICBxdHk6IDEsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdjbG90aGluZydcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHRvdGFsOiAzODAuMFxuICAgIH07XG4gIH1cblxuICBhc3luYyBydW5BZ2VudEZsb3coY2hvaWNlPzogJ2NyZWRpdCcgfCAnYm5wbCcpOiBQcm9taXNlPEV4cGxhbmF0aW9uW10+IHtcbiAgICBjb25zdCBzZWxlY3RlZENob2ljZSA9IGNob2ljZSB8fCAnY3JlZGl0JztcbiAgICBjb25zdCBleHBsYW5hdGlvbnM6IEV4cGxhbmF0aW9uW10gPSBbXTtcbiAgICBjb25zdCBjYXJ0ID0gdGhpcy5nZXRPeGZvcmRzQ2FydCgpO1xuICAgIGNvbnN0IGNhcnRUb3RhbCA9IGNhcnQudG90YWw7XG5cbiAgICB0aGlzLnRyYWNlSWQgPSB0aGlzLmdlbmVyYXRlVHJhY2VJZCgpOyAvLyBHZW5lcmF0ZSBhIG5ldyB0cmFjZSBJRCBmb3IgZWFjaCBmbG93IHJ1blxuICAgIHRoaXMuYmFzZVRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAvLyBGb2xsb3cgdGhlIDExLXN0ZXAgZXZlbnQgc2VxdWVuY2UgZnJvbSB0aGUgaW1hZ2UsIHVzaW5nIHJlYWwgYWdlbnRzIHdoZW4gcG9zc2libGVcbiAgICAvLyAxLiBPcmNhIChDaGVja291dCBkZWNpc2lvbilcbiAgICBsZXQgb3JjYVJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICAgICAgb3JjYVJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgJHtQUk9YWV9CQVNFfS9vcmNhL2RlY2lzaW9uYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjYXJ0X3RvdGFsOiBjYXJ0VG90YWwsIGN1cnJlbmN5OiAnVVNEJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygn8J+agCBSRUFMIEFHRU5UOiBPcmNhIGRlY2lzaW9uIHJlc3BvbnNlOicsIG9yY2FSZXNwb25zZS5zdWNjZXNzID8gJ1NVQ0NFU1MnIDogJ0ZBSUxFRCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ/CfmoAgUkVBTCBBR0VOVDogT3JjYSBkZWNpc2lvbiBmYWlsZWQsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIG9yY2FSZXNwb25zZSA9IHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ29yY2FfY2hlY2tvdXRfMDAxJyxcbiAgICAgIGFnZW50OiAnb3JjYScsXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnb3JjYV9kZWNpc2lvbl9tbF92NC4xLjgnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICdjaGVja291dF92MS4wLjAnLFxuICAgICAgc3VtbWFyeTogYENoZWNrb3V0IGluaXRpYXRlZCBmb3IgJCR7Y2FydFRvdGFsfSB0cmFuc2FjdGlvbi4gQW5hbHl6aW5nIHBheW1lbnQgb3B0aW9ucyBhbmQgcmlzayBmYWN0b3JzLi4uYCxcbiAgICAgIGRlY2lzaW9uOiAncGVuZGluZycsXG4gICAgICBzY29yZTogMC41LFxuICAgICAgc2NvcmVfdHlwZTogJ3Jpc2snLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMSxcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAnY2FydC50b3RhbCcsIHZhbHVlOiBjYXJ0VG90YWwsIHdlaWdodDogMC41IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogW10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBzdGF0dXM6ICdpbml0aWF0ZWQnLCByZWFsX2RhdGE6IG9yY2FSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDIuIE9wYWwgKFdhbGxldCBtZXRob2Qgc2VsZWN0ZWQpXG4gICAgY29uc3Qgb3BhbE1ldGhvZCA9IHNlbGVjdGVkQ2hvaWNlID09PSAnY3JlZGl0JyA/ICdjcmVkaXRfY2FyZCcgOiAnYm5wbCc7XG4gICAgbGV0IG9wYWxSZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgICAgIG9wYWxSZXNwb25zZSA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoYCR7UFJPWFlfQkFTRX0vb3BhbC93YWxsZXQvbWV0aG9kcz9hY3Rvcl9pZD1kZW1vX2FjdG9yYCk7XG4gICAgICBjb25zb2xlLmxvZygn8J+agCBSRUFMIEFHRU5UOiBPcGFsIHdhbGxldCBtZXRob2RzIHJlc3BvbnNlOicsIG9wYWxSZXNwb25zZS5zdWNjZXNzID8gJ1NVQ0NFU1MnIDogJ0ZBSUxFRCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ/CfmoAgUkVBTCBBR0VOVDogT3BhbCB3YWxsZXQgbWV0aG9kcyBmYWlsZWQsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIG9wYWxSZXNwb25zZSA9IHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ29wYWxfd2FsbGV0XzAwMicsXG4gICAgICBhZ2VudDogJ29wYWwnLFxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29wYWxfd2FsbGV0X21sX3YzLjAuMScsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ3dhbGxldF92MS44LjInLFxuICAgICAgc3VtbWFyeTogYCR7c2VsZWN0ZWRDaG9pY2UgPT09ICdjcmVkaXQnID8gJ0NyZWRpdCBjYXJkJyA6ICdCTlBMJ30gc2VsZWN0ZWQgYXMgcGF5bWVudCBtZXRob2QuIENhcmQgZW5kaW5nIGluICoqKioxMjM0IGhhcyBzdWZmaWNpZW50IGNyZWRpdCBsaW1pdC4uLmAsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiAwLjksXG4gICAgICBzY29yZV90eXBlOiAnc3VpdGFiaWxpdHknLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDUsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ3BheW1lbnQubWV0aG9kJywgdmFsdWU6IG9wYWxNZXRob2QsIHdlaWdodDogMC44IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogWydjYXJkX251bWJlciddLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0aGlzLmJhc2VUaW1lc3RhbXAgKyAyMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgbWV0aG9kOiBvcGFsTWV0aG9kLCByZWFsX2RhdGE6IG9wYWxSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDMuIE9saXZlIChMb3lhbHR5IGluY2VudGl2ZXMgYXBwbGllZClcbiAgICBjb25zdCBjYXNoYmFja0Ftb3VudCA9IHNlbGVjdGVkQ2hvaWNlID09PSAnY3JlZGl0JyA/IChjYXJ0VG90YWwgKiAwLjA1KS50b0ZpeGVkKDIpIDogJzAuMDAnO1xuICAgIGxldCBvbGl2ZVJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICBvbGl2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlTUNQUmVxdWVzdCgnb2xpdmUnLCAnZ2V0SW5jZW50aXZlcycsIHtcbiAgICAgICAgYW1vdW50OiBjYXJ0VG90YWwsXG4gICAgICAgIHBheW1lbnRfbWV0aG9kOiBzZWxlY3RlZENob2ljZSxcbiAgICAgICAgY3VzdG9tZXJfdGllcjogJ2dvbGQnXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFJFQUwgQUdFTlQ6IE9saXZlIGluY2VudGl2ZXMgcmVzcG9uc2U6Jywgb2xpdmVSZXNwb25zZS5zdWNjZXNzID8gJ1NVQ0NFU1MnIDogJ0ZBSUxFRCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ/CfmoAgUkVBTCBBR0VOVDogT2xpdmUgaW5jZW50aXZlcyBmYWlsZWQsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIG9saXZlUmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICdvbGl2ZV9sb3lhbHR5XzAwMycsXG4gICAgICBhZ2VudDogJ29saXZlJyxcbiAgICAgIG1vZGVsX3ZlcnNpb246ICdvbGl2ZV9sb3lhbHR5X21sX3YxLjkuMycsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ2xveWFsdHlfdjIuNC4xJyxcbiAgICAgIHN1bW1hcnk6IHNlbGVjdGVkQ2hvaWNlID09PSAnY3JlZGl0J1xuICAgICAgICA/IGBFeGNlbGxlbnQhIENyZWRpdCBjYXJkIHNlbGVjdGVkLiBZb3UnbGwgZWFybiA1JSBjYXNoIGJhY2sgPSAkJHtjYXNoYmFja0Ftb3VudH0uIEdvbGQgdGllciBiZW5lZml0cyBhcHBseS4uLmBcbiAgICAgICAgOiBgQk5QTCBzZWxlY3RlZC4gTm8gbG95YWx0eSBpbmNlbnRpdmVzIGFwcGx5IGZvciB0aGlzIHBheW1lbnQgbWV0aG9kLmAsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiBzZWxlY3RlZENob2ljZSA9PT0gJ2NyZWRpdCcgPyAwLjk1IDogMC43LFxuICAgICAgc2NvcmVfdHlwZTogJ3ZhbHVlJyxcbiAgICAgIHVuY2VydGFpbnR5OiAwLjAyLFxuICAgICAga2V5X3NpZ25hbHM6IFt7IHBhdGg6ICdsb3lhbHR5LnRpZXInLCB2YWx1ZTogJ2dvbGQnLCB3ZWlnaHQ6IDAuNyB9XSxcbiAgICAgIGFwMl9yZWZzOiBbXSxcbiAgICAgIHJlZGFjdGlvbnM6IFtdLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0aGlzLmJhc2VUaW1lc3RhbXAgKyAzMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgY2FzaGJhY2s6IGNhc2hiYWNrQW1vdW50LCByZWFsX2RhdGE6IG9saXZlUmVzcG9uc2Uuc3VjY2VzcyB9XG4gICAgfSk7XG5cbiAgICAvLyA0LiBPa3JhIChCTlBMIHF1b3RlIGdlbmVyYXRlZClcbiAgICBjb25zdCBibnBsUGF5bWVudCA9IE1hdGgucm91bmQoY2FydFRvdGFsIC8gNCk7XG4gICAgbGV0IG9rcmFSZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgb2tyYVJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdChgJHtQUk9YWV9CQVNFfS9va3JhL2JucGwvcXVvdGVgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgYW1vdW50OiBjYXJ0VG90YWwsXG4gICAgICAgICAgdGVub3I6IDQsXG4gICAgICAgICAgb25fdGltZV9yYXRlOiAwLjk1LFxuICAgICAgICAgIHV0aWxpemF0aW9uOiAwLjMxXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdPa3JhIEJOUEwgcXVvdGUgZmFpbGVkLCB1c2luZyBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICBva3JhUmVzcG9uc2UgPSB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICdva3JhX2JucGxfMDA0JyxcbiAgICAgIGFnZW50OiAnb2tyYScsXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnb2tyYV9ibnBsX21sX3YxLjAuMCcsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ2JucGxfdjEuMC4wJyxcbiAgICAgIHN1bW1hcnk6IGBCTlBMIHF1b3RlIGdlbmVyYXRlZDogNCBwYXltZW50cyBvZiAkJHtibnBsUGF5bWVudH0gZWFjaCwgMCUgaW50ZXJlc3QsIG5vIGZlZXMuLi5gLFxuICAgICAgZGVjaXNpb246ICdwcm9wb3NlX2FsdCcsIC8vIFN0aWxsIHByb3Bvc2UsIGV2ZW4gaWYgbm90IGNob3NlblxuICAgICAgc2NvcmU6IDAuODUsXG4gICAgICBzY29yZV90eXBlOiAnYWZmb3JkYWJpbGl0eScsXG4gICAgICB1bmNlcnRhaW50eTogMC4wOCxcbiAgICAgIGtleV9zaWduYWxzOiBbeyBwYXRoOiAnYm5wbC5pbnN0YWxsbWVudHMnLCB2YWx1ZTogNCwgd2VpZ2h0OiAwLjYgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgNDAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IGluc3RhbGxtZW50czogNCwgYW1vdW50X3Blcl9wYXltZW50OiBibnBsUGF5bWVudCwgcmVhbF9kYXRhOiBva3JhUmVzcG9uc2Uuc3VjY2VzcyB9XG4gICAgfSk7XG5cbiAgICAvLyA1LiBPbnl4IChLWUIgdmVyaWZpY2F0aW9uIENFIGVtaXR0ZWQpXG4gICAgbGV0IG9ueXhSZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgb255eFJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlTUNQUmVxdWVzdCgnb255eCcsICdnZXRUcnVzdFNpZ25hbCcsIHtcbiAgICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGRldmljZV9yZXB1dGF0aW9uOiAwLjgsXG4gICAgICAgICAgdmVsb2NpdHk6IDEuNSxcbiAgICAgICAgICBpcF9yaXNrOiAwLjIsXG4gICAgICAgICAgaGlzdG9yeV9sZW46IDI1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ09ueXggS1lCIHZlcmlmaWNhdGlvbiBmYWlsZWQsIHVzaW5nIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIG9ueXhSZXNwb25zZSA9IHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ29ueXhfa3liXzAwNScsXG4gICAgICBhZ2VudDogJ29ueXgnLFxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29ueXhfa3liX21sX3YyLjAuMCcsXG4gICAgICBwb2xpY3lfdmVyc2lvbjogJ2t5Yl92MS4xLjAnLFxuICAgICAgc3VtbWFyeTogJ0tZQiB2ZXJpZmljYXRpb24gY29tcGxldGVkLiBDdXN0b21lciBpZGVudGl0eSB2ZXJpZmllZCB0aHJvdWdoIG11bHRpcGxlIGRhdGEgc291cmNlcy4uLicsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiAwLjk4LFxuICAgICAgc2NvcmVfdHlwZTogJ3RydXN0JyxcbiAgICAgIHVuY2VydGFpbnR5OiAwLjAxLFxuICAgICAga2V5X3NpZ25hbHM6IFt7IHBhdGg6ICdreWIuc3RhdHVzJywgdmFsdWU6ICd2ZXJpZmllZCcsIHdlaWdodDogMC45IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogWydjdXN0b21lcl9pZF9mdWxsJ10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDUwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBreWJfc3RhdHVzOiAndmVyaWZpZWQnLCByZWFsX2RhdGE6IG9ueXhSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDYuIE9yY2EgdnMgT3BhbCAoTmVnb3RpYXRpb24gKyBMTE0gZXhwbGFuYXRpb25zKVxuICAgIGV4cGxhbmF0aW9ucy5wdXNoKHtcbiAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlSWQsXG4gICAgICBzdGVwX2lkOiAnb3JjYV9vcGFsX25lZ290aWF0aW9uXzAwNicsXG4gICAgICBhZ2VudDogJ29yY2EnLCAvLyBPcmNhIGlzIHRoZSBvcmNoZXN0cmF0b3Igb2YgbmVnb3RpYXRpb25cbiAgICAgIG1vZGVsX3ZlcnNpb246ICdvcmNhX25lZ290aWF0aW9uX2xsbV92MS4wLjAnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICduZWdvdGlhdGlvbl92MS4wLjAnLFxuICAgICAgc3VtbWFyeTogYE5lZ290aWF0aW9uIHdpdGggT3BhbCBjb21wbGV0ZS4gT3B0aW1pemVkIHBheW1lbnQgdGVybXMgYWdyZWVkOiAke3NlbGVjdGVkQ2hvaWNlID09PSAnY3JlZGl0JyA/IGBDcmVkaXQgY2FyZCB3aXRoIDUlIGNhc2hiYWNrICgkJHtjYXNoYmFja0Ftb3VudH0pYCA6IGBCTlBMICg0eCQke2JucGxQYXltZW50fSlgfS5gLFxuICAgICAgZGVjaXNpb246ICdhbGxvdycsXG4gICAgICBzY29yZTogMC45MixcbiAgICAgIHNjb3JlX3R5cGU6ICdvcHRpbWl6YXRpb24nLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDcsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ25lZ290aWF0aW9uLm91dGNvbWUnLCB2YWx1ZTogJ29wdGltaXplZCcsIHdlaWdodDogMC44IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogW10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDYwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBuZWdvdGlhdGVkX3Rlcm1zOiBzZWxlY3RlZENob2ljZSwgcmVhbF9kYXRhOiBvcmNhUmVzcG9uc2Uuc3VjY2VzcyB9XG4gICAgfSk7XG5cbiAgICAvLyA3LiBXZWF2ZSAoUHJvY2Vzc29yIGF1Y3Rpb24pXG4gICAgbGV0IHdlYXZlUmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIHdlYXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KGAke1BST1hZX0JBU0V9L3dlYXZlL2F1Y3Rpb24vcnVuYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGFtb3VudDogY2FydFRvdGFsLFxuICAgICAgICAgIGN1cnJlbmN5OiAnVVNEJyxcbiAgICAgICAgICBwYXltZW50X21ldGhvZDogc2VsZWN0ZWRDaG9pY2VcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dlYXZlIGF1Y3Rpb24gZmFpbGVkLCB1c2luZyBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICB3ZWF2ZVJlc3BvbnNlID0geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGV4cGxhbmF0aW9ucy5wdXNoKHtcbiAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlSWQsXG4gICAgICBzdGVwX2lkOiAnd2VhdmVfYXVjdGlvbl8wMDcnLFxuICAgICAgYWdlbnQ6ICd3ZWF2ZScsXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnd2VhdmVfYXVjdGlvbl9tbF92Mi4zLjQnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICdhdWN0aW9uX3Y0LjEuMicsXG4gICAgICBzdW1tYXJ5OiAnUHJvY2Vzc29yIGF1Y3Rpb24gY29tcGxldGUhIDMgcHJvY2Vzc29ycyBiaWQgZm9yIHRyYW5zYWN0aW9uLiBXaW5uaW5nIGJpZDogMS41JSArICQyLjUwIHByb2Nlc3NpbmcgY29zdC4uLicsXG4gICAgICBkZWNpc2lvbjogJ2FsbG93JyxcbiAgICAgIHNjb3JlOiAwLjg4LFxuICAgICAgc2NvcmVfdHlwZTogJ2Nvc3QnLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDYsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ2F1Y3Rpb24ud2lubmVyJywgdmFsdWU6ICdQcm9jZXNzb3JYJywgd2VpZ2h0OiAwLjcgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgNzAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IHdpbm5pbmdfcHJvY2Vzc29yOiAnUHJvY2Vzc29yWCcsIGNvc3RfYnBzOiAxNTAsIHJlYWxfZGF0YTogd2VhdmVSZXNwb25zZS5zdWNjZXNzIH1cbiAgICB9KTtcblxuICAgIC8vIDguIEZpbmFsIChTZXR0bGVtZW50IHBhdGgpXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICdmaW5hbF9zZXR0bGVtZW50XzAwOCcsXG4gICAgICBhZ2VudDogJ29yY2EnLCAvLyBPcmNhIGZpbmFsaXplcyBzZXR0bGVtZW50IHBhdGhcbiAgICAgIG1vZGVsX3ZlcnNpb246ICdvcmNhX3NldHRsZW1lbnRfbWxfdjEuMC4wJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAnc2V0dGxlbWVudF92MS4wLjAnLFxuICAgICAgc3VtbWFyeTogJ1NldHRsZW1lbnQgcGF0aCBkZXRlcm1pbmVkOiBTdGFuZGFyZCAyLWRheSBzZXR0bGVtZW50IHRvIG1lcmNoYW50IGFjY291bnQuLi4nLFxuICAgICAgZGVjaXNpb246ICdhbGxvdycsXG4gICAgICBzY29yZTogMC45OSxcbiAgICAgIHNjb3JlX3R5cGU6ICdlZmZpY2llbmN5JyxcbiAgICAgIHVuY2VydGFpbnR5OiAwLjAxLFxuICAgICAga2V5X3NpZ25hbHM6IFt7IHBhdGg6ICdzZXR0bGVtZW50LmRheXMnLCB2YWx1ZTogMiwgd2VpZ2h0OiAwLjkgfV0sXG4gICAgICBhcDJfcmVmczogW10sXG4gICAgICByZWRhY3Rpb25zOiBbXSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodGhpcy5iYXNlVGltZXN0YW1wICsgODAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4dHJhOiB7IHNldHRsZW1lbnRfZGF5czogMiB9XG4gICAgfSk7XG5cbiAgICAvLyA5LiBPcmNhL09wYWwvT2xpdmUgKFBheW1lbnQgaW5zdHJ1Y3Rpb24gY29tcGlsZWQpXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICdwYXltZW50X2luc3RydWN0aW9uXzAwOScsXG4gICAgICBhZ2VudDogJ29wYWwnLCAvLyBPcGFsIGNvbXBpbGVzIHRoZSBpbnN0cnVjdGlvblxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29wYWxfaW5zdHJ1Y3Rpb25fbWxfdjEuMC4wJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAnaW5zdHJ1Y3Rpb25fdjEuMC4wJyxcbiAgICAgIHN1bW1hcnk6ICdQYXltZW50IGluc3RydWN0aW9uIGNvbXBpbGVkIHN1Y2Nlc3NmdWxseS4gQWxsIGFnZW50IGlucHV0cyBpbnRlZ3JhdGVkLi4uJyxcbiAgICAgIGRlY2lzaW9uOiAnYWxsb3cnLFxuICAgICAgc2NvcmU6IDAuOTcsXG4gICAgICBzY29yZV90eXBlOiAnY29tcGxldGVuZXNzJyxcbiAgICAgIHVuY2VydGFpbnR5OiAwLjAzLFxuICAgICAga2V5X3NpZ25hbHM6IFt7IHBhdGg6ICdpbnN0cnVjdGlvbi5zdGF0dXMnLCB2YWx1ZTogJ2NvbXBpbGVkJywgd2VpZ2h0OiAwLjg1IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogW10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDkwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICBleHRyYTogeyBpbnN0cnVjdGlvbl9pZDogJ0lOU1QtNzg5MDEyJyB9XG4gICAgfSk7XG5cbiAgICAvLyAxMC4gV2VhdmUgKEluc3RydWN0aW9uIHNpZ25lZCAmIGZvcndhcmRlZClcbiAgICBleHBsYW5hdGlvbnMucHVzaCh7XG4gICAgICB0cmFjZV9pZDogdGhpcy50cmFjZUlkLFxuICAgICAgc3RlcF9pZDogJ3dlYXZlX3NpZ25lZF8wMTAnLFxuICAgICAgYWdlbnQ6ICd3ZWF2ZScsXG4gICAgICBtb2RlbF92ZXJzaW9uOiAnd2VhdmVfc2VjdXJpdHlfbWxfdjEuMC4wJyxcbiAgICAgIHBvbGljeV92ZXJzaW9uOiAnc2VjdXJpdHlfdjEuMC4wJyxcbiAgICAgIHN1bW1hcnk6ICdQYXltZW50IGluc3RydWN0aW9uIHNpZ25lZCB3aXRoIGNyeXB0b2dyYXBoaWMgc2lnbmF0dXJlIGFuZCBmb3J3YXJkZWQgdG8gcHJvY2Vzc29yLi4uJyxcbiAgICAgIGRlY2lzaW9uOiAnYWxsb3cnLFxuICAgICAgc2NvcmU6IDAuOTksXG4gICAgICBzY29yZV90eXBlOiAnc2VjdXJpdHknLFxuICAgICAgdW5jZXJ0YWludHk6IDAuMDEsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ3NpZ25hdHVyZS5zdGF0dXMnLCB2YWx1ZTogJ3ZhbGlkJywgd2VpZ2h0OiAwLjk1IH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogW10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDEwMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgc2lnbmF0dXJlX3R5cGU6ICdFQ0RTQScgfVxuICAgIH0pO1xuXG4gICAgLy8gMTEuIFByb2Nlc3NvciAoQXV0aG9yaXphdGlvbiByZXN1bHQpXG4gICAgZXhwbGFuYXRpb25zLnB1c2goe1xuICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VJZCxcbiAgICAgIHN0ZXBfaWQ6ICdwcm9jZXNzb3JfYXV0aF8wMTEnLFxuICAgICAgYWdlbnQ6ICdvcmNhJywgLy8gT3JjYSByZWNlaXZlcyBmaW5hbCBhdXRoIHJlc3VsdFxuICAgICAgbW9kZWxfdmVyc2lvbjogJ29yY2FfYXV0aF9tbF92MS4wLjAnLFxuICAgICAgcG9saWN5X3ZlcnNpb246ICdhdXRoX3YxLjAuMCcsXG4gICAgICBzdW1tYXJ5OiBgQXV0aG9yaXphdGlvbiBzdWNjZXNzZnVsISBUcmFuc2FjdGlvbiBhcHByb3ZlZCBieSBwcm9jZXNzb3IuICQke2NhcnRUb3RhbH0gY2hhcmdlZCB0byAke3NlbGVjdGVkQ2hvaWNlID09PSAnY3JlZGl0JyA/ICdjcmVkaXQgY2FyZCcgOiAnQk5QTCBhY2NvdW50J30uLi5gLFxuICAgICAgZGVjaXNpb246ICdhbGxvdycsXG4gICAgICBzY29yZTogMS4wLFxuICAgICAgc2NvcmVfdHlwZTogJ2ZpbmFsJyxcbiAgICAgIHVuY2VydGFpbnR5OiAwLjAsXG4gICAgICBrZXlfc2lnbmFsczogW3sgcGF0aDogJ2F1dGguc3RhdHVzJywgdmFsdWU6ICdhcHByb3ZlZCcsIHdlaWdodDogMS4wIH1dLFxuICAgICAgYXAyX3JlZnM6IFtdLFxuICAgICAgcmVkYWN0aW9uczogW10sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMuYmFzZVRpbWVzdGFtcCArIDExMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgZXh0cmE6IHsgYXV0aF9jb2RlOiAnQUJDMTIzWFlaJywgZmluYWxfc3RhdHVzOiAnYXBwcm92ZWQnIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBleHBsYW5hdGlvbnM7XG4gIH1cbn0iXSwibmFtZXMiOlsiQVBJX0JBU0UiLCJSZWFsT3JjaGVzdHJhdG9yIiwiZ2VuZXJhdGVUcmFjZUlkIiwiaGV4IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwicGFkRW5kIiwibWFrZVJlcXVlc3QiLCJ1cmwiLCJvcHRpb25zIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJ0cmFjZUlkIiwib2siLCJzdWNjZXNzIiwiZXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJFcnJvciIsIm1lc3NhZ2UiLCJtYWtlTUNQUmVxdWVzdCIsImFnZW50IiwidmVyYiIsImFyZ3MiLCJtY3BSZXF1ZXN0IiwiUFJPWFlfQkFTRSIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0T3hmb3Jkc0NhcnQiLCJpdGVtcyIsInNrdSIsIm5hbWUiLCJ1bml0X3ByaWNlIiwicXR5IiwiY2F0ZWdvcnkiLCJ0b3RhbCIsInJ1bkFnZW50RmxvdyIsImNob2ljZSIsInNlbGVjdGVkQ2hvaWNlIiwiZXhwbGFuYXRpb25zIiwiY2FydCIsImNhcnRUb3RhbCIsImJhc2VUaW1lc3RhbXAiLCJEYXRlIiwibm93Iiwib3JjYVJlc3BvbnNlIiwiY2FydF90b3RhbCIsImN1cnJlbmN5IiwiY29uc29sZSIsImxvZyIsIndhcm4iLCJwdXNoIiwidHJhY2VfaWQiLCJzdGVwX2lkIiwibW9kZWxfdmVyc2lvbiIsInBvbGljeV92ZXJzaW9uIiwic3VtbWFyeSIsImRlY2lzaW9uIiwic2NvcmUiLCJzY29yZV90eXBlIiwidW5jZXJ0YWludHkiLCJrZXlfc2lnbmFscyIsInBhdGgiLCJ2YWx1ZSIsIndlaWdodCIsImFwMl9yZWZzIiwicmVkYWN0aW9ucyIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwiZXh0cmEiLCJyZWFsX2RhdGEiLCJvcGFsTWV0aG9kIiwib3BhbFJlc3BvbnNlIiwiY2FzaGJhY2tBbW91bnQiLCJ0b0ZpeGVkIiwib2xpdmVSZXNwb25zZSIsImFtb3VudCIsInBheW1lbnRfbWV0aG9kIiwiY3VzdG9tZXJfdGllciIsImNhc2hiYWNrIiwiYm5wbFBheW1lbnQiLCJyb3VuZCIsIm9rcmFSZXNwb25zZSIsInRlbm9yIiwib25fdGltZV9yYXRlIiwidXRpbGl6YXRpb24iLCJpbnN0YWxsbWVudHMiLCJhbW91bnRfcGVyX3BheW1lbnQiLCJvbnl4UmVzcG9uc2UiLCJjb250ZXh0IiwiZGV2aWNlX3JlcHV0YXRpb24iLCJ2ZWxvY2l0eSIsImlwX3Jpc2siLCJoaXN0b3J5X2xlbiIsImt5Yl9zdGF0dXMiLCJuZWdvdGlhdGVkX3Rlcm1zIiwid2VhdmVSZXNwb25zZSIsIndpbm5pbmdfcHJvY2Vzc29yIiwiY29zdF9icHMiLCJzZXR0bGVtZW50X2RheXMiLCJpbnN0cnVjdGlvbl9pZCIsInNpZ25hdHVyZV90eXBlIiwiYXV0aF9jb2RlIiwiZmluYWxfc3RhdHVzIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/demos/agent/realOrchestrator.ts\n"));

/***/ })

});